import { viewport } from "../enums";
import getViewportRect from "./getViewportRect";
import getDocumentRect from "./getDocumentRect";
import listScrollParents from "./listScrollParents";
import getOffsetParent from "./getOffsetParent";
import getDocumentElement from "./getDocumentElement";
import getComputedStyle from "./getComputedStyle";
import { isElement, isHTMLElement } from "./instanceOf";
import getBoundingClientRect from "./getBoundingClientRect";
import getParentNode from "./getParentNode";
import contains from "./contains";
import getNodeName from "./getNodeName";
import rectToClientRect from "../utils/rectToClientRect";

/**
 * Converts a rect object to a client rect object.
 */
function rectToClientRect(rect: ClientRect): ClientRect {
  return {
    top: rect.top,
    left: rect.left,
    right: rect.right,
    bottom: rect.bottom,
    width: rect.width,
    height: rect.height,
    x: rect.x,
    y: rect.y,
  };
}

/**
 * Returns the inner bounding client rect of an element.
 */
function getInnerBoundingClientRect(element: HTMLElement): ClientRect {
  const rect = getBoundingClientRect(element);
  const { clientTop, clientLeft, clientHeight, clientWidth } = element;

  return {
    ...rect,
    top: rect.top + clientTop,
    left: rect.left + clientLeft,
    bottom: rect.top + clientHeight,
    right: rect.left + clientWidth,
    width: clientWidth,
    height: clientHeight,
    x: rect.left,
    y: rect.top,
  };
}

/**
 * Returns the client rect of an element relative to a clipping parent.
 */
function getClientRectFromMixedType(
  element: Element,
  clippingParent: Element | viewport
): ClientRect {
  if (clippingParent === viewport) {
    return rectToClientRect(getViewportRect(element));
  }

  if (isHTMLElement(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent);
  }

  return rectToClientRect(getDocumentRect(getDocumentElement(element)));
}

/**
 * Returns the scroll parents of an element that can clip its content.
 */
function getClippingParents(element: Element): Element[] {
  const clippingParents = listScrollParents(getParentNode(element));
  const canEscapeClipping = [
    "absolute",
    "fixed",
  ].indexOf(getComputedStyle(element).position) >= 0;
  const clipperElement = canEscapeClipping && isHTMLElement(element)
    ? getOffsetParent(element)
    : element;

  if (!isElement(clipperElement)) {
    return [];
  }

  return clippingParents.filter(
    (clippingParent) =>
      isElement(clippingParent) &&
      contains(clippingParent, clipperElement) &&
      getNodeName(clippingParent) !== "body"
  );
}

/**
 * Returns the maximum area that the element is visible in due to any number of
 * clipping parents.
 */
export default function getClippingRect(
  element: Element,
  boundary: "clippingParents" | Element[] = "clippingParents",
  rootBoundary: Element | viewport = viewport
): ClientRect {
  const mainClippingParents = Array.isArray(boundary)
    ? boundary
    : getClippingParents(element);

  const clippingParents = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents[0];

  const clippingRect = clippingParents.reduce(
    (accRect: ClientRect, clippingParent) => {
      const rect = getClientRectFromMixedType(element, clippingParent);

      accRect.top = Math.max(rect.top, accRect.top);
      accRect.right = Math.min(rect.right, accRect.right);
      accRect.bottom = Math.min(rect.bottom, accRect.bottom);
      accRect.left = Math.max(rect.left, accRect.left);

      return accRect;
    },
    getClientRectFromMixedType(element, firstClippingParent)
  );

  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;

  return clippingRect;
}
