import getOppositePlacement from "../utils/getOppositePlacement.js";
import getBasePlacement from "../utils/getBasePlacement.js";
import getOppositeVariationPlacement from "../utils/getOppositeVariationPlacement.js";
import detectOverflow from "../utils/detectOverflow.js";
import computeAutoPlacement from "../utils/computeAutoPlacement.js";
import {
    Placement,
    Direction,
    Variation,
    Overflow,
    ModifierFunction,
    ModifierData,
    ModifierOptions,
    ModifierResult,
    AutoPlacement,
    Rect,
    PlacementMap
} from "../types.js";

const enum Directions {
    TOP = "top",
    RIGHT = "right",
    BOTTOM = "bottom",
    LEFT = "left",
    AUTO = "auto"
}

const enum Variations {
    START = "start",
    END = "end"
}

const getOppositeDirection = (direction: Direction): Direction => {
    switch (direction) {
        case Directions.TOP:
            return Directions.BOTTOM;
        case Directions.RIGHT:
            return Directions.LEFT;
        case Directions.BOTTOM:
            return Directions.TOP;
        case Directions.LEFT:
            return Directions.RIGHT;
        default:
            return direction;
    }
};

const getOppositeVariation = (variation: Variation): Variation => {
    switch (variation) {
        case Variations.START:
            return Variations.END;
        case Variations.END:
            return Variations.START;
        default:
            return variation;
    }
};

const getExpandedFallbackPlacements = (placement: Placement): Placement[] => {
    const basePlacement = getBasePlacement(placement);

    if (basePlacement === Directions.AUTO) {
        return [];
    }

    const oppositePlacement = getOppositePlacement(placement);

    return [
        getOppositeVariationPlacement(placement),
        oppositePlacement,
        getOppositeVariationPlacement(oppositePlacement)
    ];
};

const isValidPlacement = (placement: Placement): boolean => {
    const basePlacement = getBasePlacement(placement);

    return (
        [
            Directions.TOP,
            Directions.RIGHT,
            Directions.BOTTOM,
            Directions.LEFT,
            Directions.AUTO
        ].includes(basePlacement) &&
        [Variations.START, Variations.END].includes(getVariation(placement))
    );
};

const isValidOverflow = (overflow: Overflow): boolean => {
    return (
        Object.values(Overflow).includes(overflow) &&
        Object.values(Overflow).includes(overflow[getOppositeDirection(overflow as Direction)])
    );
};

const isValidOption = (option: string): boolean => {
    return (
        [
            "mainAxis",
            "altAxis",
            "fallbackPlacements",
            "padding",
            "boundary",
            "rootBoundary",
            "altBoundary",
            "flipVariations",
            "allowedAutoPlacements"
        ].includes(option)
    );
};

const flip = (
    {
        state,
        options
    }: {
        state: {
            rects: {
                reference: Rect;
                popper: Rect;
            };
            placement: Placement;
            modifiersData: PlacementMap<ModifierData>;
        };
        options: ModifierOptions;
    },
    {
        name
    }: {
        name: string;
    }
): ModifierResult => {
    if (state.modifiersData[name]._skip) {
        return;
    }

    const {
        mainAxis = true,
        altAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        padding,
        boundary,
        rootBoundary,
        altBoundary: altBoundaryProp,
        flipVariations = true,
        allowedAutoPlacements: allowedAutoPlacementsProp
    } = options;

    const fallbackPlacements =
        specifiedFallbackPlacements ||
        (getBasePlacement(state.placement) === Directions.AUTO ? [
            getOppositePlacement(state.placement)
        ] : getExpandedFallbackPlacements(state.placement));

    const validFallbackPlacements = fallbackPlacements.filter(isValidPlacement);

    if (validFallbackPlacements.length === 0) {
        console.error("No valid fallback placements found");
        return;
    }

    const placements = [state.placement].concat(validFallbackPlacements).reduce<
        Placement[]
    >((acc, placement) => {
        const basePlacement = getBasePlacement(placement);

        return acc.concat(
            basePlacement === Directions.AUTO ? (
                computeAutoPlacement(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding,
                    flipVariations,
                    allowedAutoPlacements: allowedAutoPlacementsProp
                })
            ) : placement
        );
    }, []);

    const referenceRect = state.rects.reference;
    const popperRect = state.rects.popper;
    const checksMap = new Map<Placement, boolean[]>();
    let firstFittingPlacement: Placement | null
