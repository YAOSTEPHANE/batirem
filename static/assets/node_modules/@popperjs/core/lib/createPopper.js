import getCompositeRect from "./dom-utils/getCompositeRect.js";
import getLayoutRect from "./dom-utils/getLayoutRect.js";
import listScrollParents from "./dom-utils/listScrollParents.js";
import getOffsetParent from "./dom-utils/getOffsetParent.js";
import getComputedStyle from "./dom-utils/getComputedStyle.js";
import orderModifiers from "./utils/orderModifiers.js";
import debounce from "./utils/debounce.js";
import validateModifiers from "./utils/validateModifiers.js";
import uniqueBy from "./utils/uniqueBy.js";
import getBasePlacement from "./utils/getBasePlacement.js";
import mergeByName from "./utils/mergeByName.js";
import detectOverflow from "./utils/detectOverflow.js";
import { isElement } from "./dom-utils/instanceOf.js";
import { auto } from "./enums.js";

const INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';
const INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';

const DEFAULT_OPTIONS = {
    placement: 'bottom',
    modifiers: [],
    strategy: 'absolute'
};

function areValidElements() {
    for (let _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
    }

    return !args.some(element => ! (element && typeof element.getBoundingClientRect === 'function'));
}

const popperGenerator = (generatorOptions = {}) => {
    const { defaultModifiers = [], defaultOptions = DEFAULT_OPTIONS } = generatorOptions;

    return function createPopper(reference, popper, options = defaultOptions) {
        let state = {
            placement: 'bottom',
            orderedModifiers: [],
            options,
            modifiersData: {},
            elements: {
                reference,
                popper
            },
            attributes: {},
            styles: {}
        };
        let effectCleanupFns = [];
        let isDestroyed = false;
        const instance = {
            state,
            setOptions: (options) => {
                cleanupModifierEffects();
                state.options = Object.assign(Object.assign({}, DEFAULT_OPTIONS), state.options, options);
                state.scrollParents = {
                    reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                    popper: listScrollParents(popper)
                }; // Orders the modifiers based on their dependencies and `phase`
                // properties

                const orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers

                state.orderedModifiers = orderedModifiers.filter(m => m.enabled); // Validate the provided modifiers so that the consumer will get warned
                // if one of the modifiers is invalid for any reason

                if (process.env.NODE_ENV !== "production") {
                    const modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), modifier => modifier.name);
                    validateModifiers(modifiers);

                    if (getBasePlacement(state.options.placement) === auto) {
                        const flipModifier = state.orderedModifiers.find(modifier => modifier.name === 'flip');

                        if (!flipModifier) {
                            console.error(['Popper: "auto" placements require the "flip" modifier be', 'present and enabled to work.'].join(' '));
                        }
                    }

                    const _getComputedStyle = getComputedStyle(popper),
                          marginTop = _getComputedStyle.marginTop,
                          marginRight = _getComputedStyle.marginRight,
                          marginBottom = _getComputedStyle.marginBottom,
                          marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can
                    // cause bugs with positioning, so we'll warn the consumer


                    if ([marginTop, marginRight, marginBottom, marginLeft].some(margin => parseFloat(margin))) {
                        console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', 'between the popper and its reference element or boundary.', 'To replicate margin, use the `offset` modifier, as well as', 'the `padding` option in the `preventOverflow` and `flip`', 'modifiers.'].join(' '));
                    }
                }

                runModifierEffects();
                return instance.update();
            },
            // Sync update â€“ it will always be executed, even if not necessary. This
            // is useful for low frequency updates where sync behavior simplifies the
            // logic.
            // For high frequency updates (e.g. `resize` and `scroll` events), always
            // prefer the async Popper#update method
            forceUpdate: () => {
                if (isDestroyed) {
                    return;
                }

                const {
